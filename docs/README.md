# 기능 구현 목록

---

# 1. 입력 기능

### 다리의 길이 입력
- 플레이어의 입력 
- 3 이상 20이하의 자연수
- 잘못된 값 입력시 다시 입력(그 부분부터)


### 이동할 칸 입력
- 플레이어의 입력
- U 혹은 D 입력 가능

### 재시작 or 종료 입력 기능 
- 플레이어의 입력
- R 혹은 Q 입력 가능

# 2. 출력 기능 

### 출력
- 게임 시작 문구
- 진행 상황 문구
- 결과 출력 문구
    - 최종 게임 결과(건넌 다리)
    - 성공 여부
    - 총 시도 횟수

# 3. 게임 로직

### 다리 생성
- 입력 받은 숫자로 생성
- 위 칸 혹은 아래 칸으로, 이에 대한 결정은 0과 1중 무작위 값을 이용하여 설정
- 0인 경우 아래칸, 1인 경우 위칸이 건너갈 수 있는 칸
- 건너갈 수 있는 칸이 위 칸이면 U, 아래칸이면 D

### 입력한 이동할 칸에 대한 결과 처리 (건너기)
- 생성한 다리와 입력한 값에 대한 비교 
- 건널 수 있다면 O, 없으면 X로 출력 

### 건너기 실패시 처리 
- 재시작 혹은 반복에 대한 플레이어의 입력 
- R 혹은 Q를 입력 가능 


# 4. 예외 처리

### 사용자 입력 오류 처리
- 다리 길이 입력시 3 이상 20 이하의 자연수이어야 함
- 이동할 칸 입력시 U 혹은 D 둘 중에 하나여야 함
- 게임 재시작/종료 선택 입력시 R 혹은 Q 둘 중에 하나여야 함

---

## <설계> 쟁점 및 아이디어

<details>
<summary>자세히</summary>

#### **개발을 시작하기 전 설계 단계에서의 쟁점 및 아이디어에 대한 기록이다**

[ 사전 설계 및 구상 ]

1. 시작하기에 앞서 게임의 전체 플로우를 이해하고자 손으로 알고리즘 흐름을 작성해보았다.

    ![img](./img/게임플로우이해.jpg)

2. 클래스 다이어그램을 만들어 클래스 및 메서드 간의 흐름과 역할을 정리해보았다. 

![img](./img/Class%20Diagram.png)


이 클래스 다이어그램을 작성하면서 집중한 포인트는 객체들 간 메시지를 주고 받으면서 각자 맡은 역할에 대한 임무를 요청/수행하는 관계를 설정한 부분이다. 

또 하나 주목한 점은 객체는 'what he is'라는 점이다([엘레강트 오브젝트](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=258374007), Yegor 저, 조영호 역). 무엇을 캡슐화할 것인가? 객체는 무엇이며 어떻게 이름을 붙이고 존재성을 부여할 것인가를 고민하였다. 

3. 이와 같은 사전 설계 구상은 실제 프로그래밍을 진행하면서 바뀔 수 있지만 지난 과제 수행중 깨달은 바, 사전 설계의 중요성에 따라 충분한 구상 작업이 필요하다고 느꼈기 때문에 수행하였다.

<br>

[ 쟁점 및 아이디어]

1. 사용자 입력을 받을때 String으로 입력받는다. 하지만 다리의 길이에서 필요한 타입은 int이다. 간단히 return시 형변환을 할 수 있긴 하지만 그럴 경우 input 메서드는 여러가지 일을 하는 꼴이 된다. 이부분 처리를 고민해보아야 한다.

2. 사용자 입력 값에 대한 validation도 마찬가지이다. 이것을 inputView에서 하는 것이 맞을까 아니면 새로운 클래스를 형성해 위임하는 것이 맞을까. 

3. 핵심 로직에서 건너기를 실행할 때 4가지 케이스로 구분되는 것에 주목한다. U를 선택하였을 때 맞는 경우와 틀린 경우가 있다. D를 선택하였을 때 맞는 경우와 틀린 경우가 있다. 

4. 출력시 처음의 것은 [ ? ] 형식이고 두 번째부터는 | ? ] 형식이다. 따라서 위 아래 다리를 나눠서 StringBuilder로 붙여나가는 방식을 고려해본다.

5. 마지막 출력 문구에서 게임 성공 여부가 있다. 이를 플래그로 지정해서 출력시 판단하는 로직을 거쳐 출력할 것인가, 아니면 사용자 입력 선택 알고리즘 과정에서 실패후 부터 시작되는 로직에서 이어나가 바로 처리할 것인가.

6. inputView와 outputView는 나뉘어져 각각 입력과 출력 역할을 담당한다. 그런데 input을 요청하는 과정에서 입력에 대한 요청을 메시지로서 '출력' 한다. 여기서의 출력을 단순하게 System.out.println으로 할 것인지, 아니면 outputView에 역할을 담당하도록 할 것인지 고민한다.
현재 내린 결론은 일단 inputView는 input만 하는 것이 맞으며 출력 메시지를 여기서 보내지 않는다. 요청시에 필요한 print message는 요청하는 측에서 하는 것이 맞다. 그리고 print라는 방법 자체를 outputView에 위임한다. 

7. 이번 프로젝트에서는 상수 사용을 객체의 존재와 역할에 맞게 할당한다. 이전에는 상수를 특정 클래스에 몰아넣고 불러오는 방식을 썼는데 그와 같은 방식에서는 상수라는 객체가 가진 의미가 사실상 없고 이용당하는 것에 불과하다고 결론내렸다. 따라서 실제 역할을 담당하는 객체가 상수 역시 지니도록 한다. 

8. 프로그램의 확장성을 고려해보자. 
- 만약 다리가 추가된다면? 즉, 위 아래에 중간이 추가된다면? 
- 다리는 왼쪽에서 오른쪽으로 이동하는데 만약 돌아오는 과정이 추가된다면? 
- 다리를 건널 때 한 칸이 아니라 두 칸, 세 칸 등 복수의 칸 이동이 가능하다면? 


</details>

<br>


## <개발> 쟁점 및 아이디어

<details>
<summary>자세히</summary>

1. inputView의 역할을 어디까지 할 것인지 고민했다. 우선 inputView의 본 기능은 console의 입력값을 받는 것이므로 interface로부터 해당 기능을 extends하는 것이 맞다고 결론을 내렸다. 이후, emptyness에 대한 검증을 여기서 하는 것이 맞느냐의 문제에 대해 고민했고, 일반론적인 input 자체라면 empty 검증 기능을 이 클래스가 가질 필요가 없겠지만, 이 게임 상에서 해당하는 룰을 이 클래스에 적용할 수 있다고 생각하여 (즉, BridgeGameInputView라고 생각하여) empty 검증을 수행하기로 했다.
2. InputValidator 인터페이스를 구현함에 있어서, 불특정 object 방식을 사용하는 것이 옳다고 생각하여 inputValidator<T>로 작성했고 그 결과 validation시 형변환이 필요해졌다. 이렇게 할경우 String 함수의 isEmpty를 사용하지 못하며, equals 메소드를 사용한 "" 자체에 대한 검증이 들어간다. 이것이 좀 더 원론적인 검증에 가까운 것이라는 결론에 따라 이 방식을 고수했다. 
3. BridgeSize를 int값이 아니라 객체화하여 반환하도록 했다. 마찬가지로 BridgeSize 역시 자체적인 검증을 본 클래스에서 하도록 한다. 

4. print 메소드를 outputView에서 처리할 때 static으로 해야하는 것인지 고민해보자. 

5. movement 역시 객체화하였는데 로직이 단순하기 때문에 validation과 "U" 혹은 "D" 리턴을 getter 없이 바로 할 수 있는 방법이 있을지 고민해본다. 

6. 입력이 잘못되었을 때 처리하는 기능을 Game 객체에서 하지 않고 inputView에 위임하도록 한다. 기존에 try - catch 문에서 재시도 하는 메서드를 따로 생성해서 하는 로직을 썼는데 이 경우 null 이 반환되는 문제가 생긴다. 단순하게 try - catch에서 재귀 호출을 해주는 것으로 해결 가능했다. 

6. BridgeMaker에서 다리를 생성하는데 로직은 랜덤 숫자 생성 => 숫자에 따른 up down 부여 => U, D 스트링으로 변경 => 다시 리스트로 넣기가 기본 로직이었는데 for문과 if문이 너무 반복되었고 무엇보다 0과 1, U와 D가 하드코딩처럼 느껴졌다. 이것은 로또 미션에서 RANK를 처리할 때와 비슷한 것이었기 때문에 이번에는 반드시 다른 방법을 찾아보고 싶었고, Enum 클래스에서 요소들간의 대응되는 것을 통해 특정 요소를 추출하는 방법에 대해 구글링 하여 values를 가져오고 이를 stream 반복문에서 대응되는 값으로 뽑아내는 방법을 찾아 구현했다. 파이썬이라면 아마 dictionary에서 map이나 람다를 사용해서 하는 방법을 고민했을 것 같다고 생각했고 이 경험을 토대로 자바에서 방법을 강구한 것이 효과가 있었다. enum과 stream을 사용해서 좀 더 단순화하였다. 

7. 생성한 브릿지를 건너는 방식에서 retrain을 써서 리스트를 지워 가는 로직을 구현했는데, retry시에 다시 초기화되어 처음의 bridge 부터 다시 불러와야 한다는 문제가 있었다. 해결을 위해 clone하는 방법을 찾느라 상당히 애를 먹었다. 과정에서 bridge를 객체 시킬 수 있었고, 분리된 클래스 상에서 clone을 만드는 방법을 찾을 수 있었다.

8. 게임이 순환성을 갖는 지점에서 do while문을 자주 사용하게 되는데 반복문 자체가 헷갈리고 어려운 부분이 있다 보니 구현 자체가 쉽지 않은 듯 하다. 이 로직을 do while 문을 사용하지 않고 좀 더 직관적이면서 깔끔하게 하는 법에 대한 고민이 필요하다.

9. retry 선택시에 알고리즘의 첫 상단으로 다시 올라가는 로직을 구현함에 있어서 필요한 객체들이 계속해서 생기는데 마찬가지로 깔끔한 처리 방법을 고민해볼 필요가 있다.

10. BridgeGame의 존재성에 대해 어떤 역할만 갖는지 고민해보면 crossing 기능과 judgement 기능은 분화해서 객체화시켜도 좋을 듯 싶다.

v1 release 

___

리팩토링 계획 및 진행 사항 체크

1. [ ] OutputView에 출력 역할 위임, 개별 메시지를 메서드별로 담당하도록 한다. <br>
=> 게임을 총괄하는 BridgeGame에서 출력의 역할을 맡아야 하는 것이라는 생각으로 v1에서 구성했다. 이 부분은 여전히 고민이 되는 부분이다.

2. [ ]  BridgeGame의 존재성은 게임의 총괄이다. 그런데 클래스에 필드가 너무 많고 crossing 기능, judging 기능을 구현하고 있고 출력 역할까지 담당하고 있다. bridgeGame 객체에 대한 정의를 명확하고 단순화할 필요가 있다. <br>

3. [ ] 변수명 통일이 필요하다. 현재 cross, pass, retry, trial, command, map, description 등 너무 많은 중복 의미의 단어들이 쓰이고 있다. <br>

4. [ ] 필드와 static을 사용한 메시지 공유 기능을 정리할 필요가 있다. <br>

6. [ ] 테스트 기능 구현이 필요하다. 

</details>

<br>


